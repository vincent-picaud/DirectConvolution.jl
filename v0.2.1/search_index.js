var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DirectConvolution","category":"page"},{"location":"#DirectConvolution","page":"Home","title":"DirectConvolution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DirectConvolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package allows efficient computation of","category":"page"},{"location":"","page":"Home","title":"Home","text":"gammak = sumlimits_iinOmega_alphaalphaibetak+lambda i","category":"page"},{"location":"","page":"Home","title":"Home","text":"where alpha is a filter of support Omega_alpha defined as follows (see filter of support):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Omega_alpha = llbracket -textoffset(alpha) -textoffset(alpha) +textlength(alpha)-1 rrbracket","category":"page"},{"location":"","page":"Home","title":"Home","text":".","category":"page"},{"location":"","page":"Home","title":"Home","text":"For lambda=-1 you get a convolution, for lambda=+1 a wiki:cross-correlation whereas using lambda=pm 2^n is useful to implement the undecimated wavelet transform (the so called wiki:algorithme à trous).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DirectConvolution\nusing DelimitedFiles\nusing LinearAlgebra\n\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()\n\nrootDir  = joinpath(dirname(pathof(DirectConvolution)), \"..\")\ndataDir = joinpath(rootDir,\"data\")\n","category":"page"},{"location":"#Use-cases","page":"Home","title":"Use cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These demos use data stored in the data/ folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"dataDir","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are one 1D signal and one 2D signal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D = readdlm(joinpath(dataDir,\"signal_1.csv\"),','); \ndata_1D_x = @view data_1D[:,1]\ndata_1D_y = @view data_1D[:,2]\nplot(data_1D_x,data_1D_y,label=\"signal\") ","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_2D=readdlm(joinpath(dataDir,\"surface.data\"));\nsurface(data_2D,label=\"2D signal\")","category":"page"},{"location":"#Savitzky-Golay-filters","page":"Home","title":"Savitzky-Golay filters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This example shows how to compute and use wiki: Savitzky-Golay filters.","category":"page"},{"location":"#Filter-creation","page":"Home","title":"Filter creation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Creates a set of Savitzky-Golay filters using polynomial of degree 3 with a window width of 11=2times 5+1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sg = SG_Filter(Float64,halfWidth=5,degree=3);","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be checked with ","category":"page"},{"location":"","page":"Home","title":"Home","text":"length(sg)\npolynomialOrder(sg)","category":"page"},{"location":"#D-signal-smoothing","page":"Home","title":"1D signal smoothing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Apply this filter on an unidimensional signal:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D_y_smoothed = apply_SG_filter(data_1D_y,sg,derivativeOrder=0)\n\nplot(data_1D_x,data_1D_y_smoothed,linewidth=3,label=\"smoothed signal\")\nplot!(data_1D_x,data_1D_y,label=\"signal\")","category":"page"},{"location":"#D-signal-smoothing-2","page":"Home","title":"2D signal smoothing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create two filters, one for the I direction, the other for the J direction. Then, apply these filters on a two dimensional signal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sg_I = SG_Filter(Float64,halfWidth=5,degree=3);\nsg_J = SG_Filter(Float64,halfWidth=3,degree=3);\n\ndata_2D_smoothed = apply_SG_filter2D(data_2D,\n                               sg_I,\n                               sg_J,\n                               derivativeOrder_I=0,\n                               derivativeOrder_J=0)\n\nsurface(data_2D_smoothed,label=\"Smoothed 2D signal\");","category":"page"},{"location":"#Wavelet-transform","page":"Home","title":"Wavelet transform","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Choose a wavelet filter:","category":"page"},{"location":"","page":"Home","title":"Home","text":"filter = UDWT_Filter_Starck2{Float64}()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Perform a UDWT transform:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D_udwt = udwt(data_1D_y,filter,scale=8)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plot Results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"label=[\"W$i\" for i in 1:scale(data_1D_udwt)];\nplot(data_1D_udwt.W,label=reshape(label,1,scale(data_1D_udwt)))\nplot!(data_1D_udwt.V,label=\"V$(scale(data_1D_udwt))\");\nplot!(data_1D_y,label=\"signal\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Inverse the transform (more precisely because of the coefficient redundancy, a pseudo-inverse is used):","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D_y_reconstructed = inverse_udwt(data_1D_udwt);\nnorm(data_1D_y-data_1D_y_reconstructed)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To smooth the signal a (very) rough solution would be to cancel the two finer scales:","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D_udwt.W[:,1] .= 0\ndata_1D_udwt.W[:,2] .= 0\n\ndata_1D_y_reconstructed = inverse_udwt(data_1D_udwt)\n\nplot(data_1D_y_reconstructed,linewidth=3, label=\"smoothed\");\nplot!(data_1D_y,label=\"signal\")","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DirectConvolution]","category":"page"},{"location":"#DirectConvolution.BoundaryExtension","page":"Home","title":"DirectConvolution.BoundaryExtension","text":"abstract type BoundaryExtension end\n\nAbstract type associated to boundary extension. \n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.ConstantBE","page":"Home","title":"DirectConvolution.ConstantBE","text":"struct ConstantBE <: BoundaryExtension end\n\nA type used to tag constant constant extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.LinearFilter","page":"Home","title":"DirectConvolution.LinearFilter","text":"abstract type LinearFilter{T<:Number} end\n\nAbstract type defining a linear filter. \n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.LinearFilter_Default","page":"Home","title":"DirectConvolution.LinearFilter_Default","text":"struct LinearFilter_Default{T<:Number,N}\n\nDefault linear filter.\n\nYou can create a filter as follows\n\njulia> linear_filter=LinearFilter([1,-2,1],1)\nFilter(r=-1:1,c=[1.0, -2.0, 1.0])\n\n\njulia> offset(linear_filter)\n1\n\n\njulia> range(linear_filter)\n-1:1\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.MirrorBE","page":"Home","title":"DirectConvolution.MirrorBE","text":"struct MirrorBE <: BoundaryExtension end\n\nA type used to tag mirror extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.PeriodicBE","page":"Home","title":"DirectConvolution.PeriodicBE","text":"struct PeriodicBE <: BoundaryExtension end\n\nA type used to tag periodic extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.SG_Filter","page":"Home","title":"DirectConvolution.SG_Filter","text":"function SG_Filter(T::DataType=Float64;halfWidth::Int=5,degree::Int=2)\n\nCreates a SG_Filter structure used to store Savitzky-Golay filters.\n\nfilter length is 2*halfWidth+1 \npolynomial degree is degree, which defines maxDerivativeOrder\n\nYou can apply these filters using the \n\napply_SG_filter\napply_SG_filter2D\n\nfunctions.\n\nExample:\n\njulia> sg = SG_Filter(halfWidth=5,degree=3);\n\n\njulia> maxDerivativeOrder(sg)\n3\n\njulia> length(sg)\n11\n\njulia> filter(sg,derivativeOrder=2)\nFilter(r=-5:5,c=[0.03497, 0.01399, -0.002331, -0.01399, -0.02098, -0.02331, -0.02098, -0.01399, -0.002331, 0.01399, 0.03497])\n\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.UDWT_Filter","page":"Home","title":"DirectConvolution.UDWT_Filter","text":"abstract type UDWT_Filter{T<:Number} <: UDWT_Filter_Biorthogonal{T} end\n\nA specialization of UDWT_Filter_Biorthogonal for orthogonal filters.\n\nFor orthogonal filters we have:  ϕ=tildeϕ, ψ=tildeψ\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.UDWT_Filter_Biorthogonal","page":"Home","title":"DirectConvolution.UDWT_Filter_Biorthogonal","text":"abstract type UDWT_Filter_Biorthogonal{T<:Number} end\n\nAbstract type defining the ϕ, ψ, tildeϕ and tildeψ filters associated to an undecimated biorthogonal wavelet transform\n\nSubtypes of this structure are:\n\nUDWT_Filter\n\nAssociated methods are:\n\nϕ_filter\nψ_filter\ntildeϕ_filter\ntildeψ_filter\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.ZeroPaddingBE","page":"Home","title":"DirectConvolution.ZeroPaddingBE","text":"struct ZeroPaddingBE <: BoundaryExtension end\n\nA type used to tag zero padding extension\n\n\n\n\n\n","category":"type"},{"location":"#Base.filter-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.filter","text":"function filter(sg::SG_Filter{T,N};derivativeOrder::Int=0)\n\nReturns the filter to be used to compute the smoothed derivatives of order derivativeOrder.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{LinearFilter}","page":"Home","title":"Base.length","text":"length(c::LinearFilter)::Int\n\nReturns filter length\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.length","text":"function length(sg::SG_Filter{T,N})\n\nReturns filter length, this is an odd number.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#Base.range-Tuple{LinearFilter}","page":"Home","title":"Base.range","text":"range(c::LinearFilter)::UnitRange\n\nReturns filter range Ω\n\nFilter support of a filter α is defined by Ω = [ - offset(α), length(α) -  offset(α) - 1 ]\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.apply_SG_filter-Union{Tuple{T}, Tuple{AbstractVector{T}, SG_Filter{T, N} where N}} where T<:AbstractFloat","page":"Home","title":"DirectConvolution.apply_SG_filter","text":"function apply_SG_filter(signal::Array{T,1},\n                         sg::SG_Filter{T};\n                         derivativeOrder::Int=0,\n                         left_BE::Type{<:BoundaryExtension}=ConstantBE,\n                         right_BE::Type{<:BoundaryExtension}=ConstantBE)\n\nApplies an 1D Savitzky-Golay and returns the smoothed signal.\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.apply_SG_filter2D-Union{Tuple{T}, Tuple{AbstractMatrix{T}, SG_Filter{T, N} where N, SG_Filter{T, N} where N}} where T<:AbstractFloat","page":"Home","title":"DirectConvolution.apply_SG_filter2D","text":"function apply_SG_filter2D(signal::Array{T,2},\n                           sg_I::SG_Filter{T},\n                           sg_J::SG_Filter{T};\n                           derivativeOrder_I::Int=0,\n                           derivativeOrder_J::Int=0,\n                           min_I_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           max_I_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           min_J_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           max_J_BE::Type{<:BoundaryExtension}=ConstantBE)\n\nApplies an 2D Savitzky-Golay and returns the smoothed signal.\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.boundaryExtension","page":"Home","title":"DirectConvolution.boundaryExtension","text":"boundaryExtension(β::AbstractArray{T,1},\n                  k::Int,\n                  ::Type{BOUNDARY_EXT_TYPE})\n\nComputes extended boundary value β[k] given boundary extension type BOUNDARY_EXT_TYPE\n\nAvailable BOUNDARY_EXT_TYPE are:\n\nZeroPaddingBE: zero padding\nConstantBE: constant boundary extension padding\nPeriodicBE: periodic boundary extension padding\nMirrorBE: mirror symmetry boundary extension padding\n\nThe routine is robust in the sens that there is no restriction on k value.\n\njulia> dom = [-5:10;];\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,ZeroPaddingBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  0   0   0   0   0  0  1  2  3  0  0  0  0  0  0   0\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,ConstantBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  1   1   1   1   1  1  1  2  3  3  3  3  3  3  3   3\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,PeriodicBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  1   2   3   1   2  3  1  2  3  1  2  3  1  2  3   1\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,MirrorBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  3   2   1   2   3  2  1  2  3  2  1  2  3  2  1   2\n\n\n\n\n\n\n","category":"function"},{"location":"#DirectConvolution.directConv!-Union{Tuple{RightBE}, Tuple{LeftBE}, Tuple{T}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}, Type{LeftBE}}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}, Type{LeftBE}, Type{RightBE}}} where {T<:Number, LeftBE<:BoundaryExtension, RightBE<:BoundaryExtension}","page":"Home","title":"DirectConvolution.directConv!","text":"directConv!\n\nComputes a convolution.\n\ngammak=sumlimits_iinOmega^alphaalphaibetak+lambda i\n\nThe following example shows how to apply inplace the [0 0 1] filter on γ[5:10] \n\njulia> β=[1:15;];\n\njulia> γ=ones(Int,15);\n\njulia> α=LinearFilter([0,0,1],0);\n\njulia> directConv!(α,1,β,γ,5:10)\n\njulia> hcat([1:length(γ);],γ)\n15×2 Matrix{Int64}:\n  1   1\n  2   1\n  3   1\n  4   1\n  5   7\n  6   8\n  7   9\n  8  10\n  9  11\n 10  12\n 11   1\n 12   1\n 13   1\n 14   1\n 15   1\n\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.fcoef-Tuple{LinearFilter}","page":"Home","title":"DirectConvolution.fcoef","text":"fcoef(c::LinearFilter)\n\nReturns filter coefficients\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.maxDerivativeOrder-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"DirectConvolution.maxDerivativeOrder","text":"function maxDerivativeOrder(sg::SG_Filter{T,N})\n\nMaximum order of the smoothed derivatives we can compute using sg filters.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.offset-Tuple{LinearFilter}","page":"Home","title":"DirectConvolution.offset","text":"offset(c::LinearFilter)::Int\n\nReturns filter offset\n\nCaveat: the first position is 0 (and not 1)\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.polynomialOrder-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"DirectConvolution.polynomialOrder","text":"function polynomialOrder(sg::SG_Filter{T,N})\n\nReturns the degree of the polynomial used to construct the Savitzky-Golay filters. This is mainly a 'convenience' function, as it is equivalent to maxDerivativeOrder\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.scale-Tuple{Int64, UnitRange{Int64}}","page":"Home","title":"DirectConvolution.scale","text":"scale(λ::Int,Ω::UnitRange{Int})\n\nRange scaling.\n\nCaveat:\n\nWe do not use Julia * operator as it returns a step range:\n\njulia> r=6:8\n6:8\n\njulia> -2*r\n-12:-2:-16\n\nWhat we need is:\n\njulia> r=6:8\n6:8\n\njulia> scale(-2,r)\n-16:-12\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.ϕ_filter-Tuple{DirectConvolution.UDWT_Filter_Biorthogonal}","page":"Home","title":"DirectConvolution.ϕ_filter","text":"ϕ_filter(c::UDWT_Filter_Biorthogonal)\n\nReturns the ϕ filter\n\n\n\n\n\n","category":"method"}]
}
