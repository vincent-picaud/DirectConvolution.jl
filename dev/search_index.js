var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DirectConvolution","category":"page"},{"location":"#DirectConvolution","page":"Home","title":"DirectConvolution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DirectConvolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DirectConvolution\nusing DelimitedFiles\nusing Plots\ngr()\n\nrootDir  = joinpath(dirname(pathof(DirectConvolution)), \"..\")\ndataDir = joinpath(rootDir,\"data\")\n","category":"page"},{"location":"#Use-cases","page":"Home","title":"Use cases","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These demos use data stored in the data/ folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D = readdlm(\"data/signal_1.csv\",',')\nPlots.plot(data_1D[:,1],data_1D[:,2])","category":"page"},{"location":"","page":"Home","title":"Home","text":"data_1D=readdlm(joinpath(dataDir,\"signal_1.csv\"),',')\nPlots.plot(data_1D[:,1],data_1D[:,2])","category":"page"},{"location":"#Savitzky-Golay-filters","page":"Home","title":"Savitzky-Golay filters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Savitzky-Golay filters are a common approach to compute smoothed derivatives of a signal.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Creates a set of Savitzky-Golay filters using polynomial of degree 3 with a window width of 11=2times 5+1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sg = SG_Filter(Float64,halfWidth=5,degree=3);","category":"page"},{"location":"","page":"Home","title":"Home","text":"This can be checked with ","category":"page"},{"location":"","page":"Home","title":"Home","text":"length(sg)\npolynomialOrder(sg)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now apply filter:","category":"page"},{"location":"","page":"Home","title":"Home","text":"smoothed_data_y = data_1D[:,2]\n\nsmoothed_data_y = apply_SG_filter(smoothed_data_y,sg,derivativeOrder=0)\n\nPlots.plot(data_1D[:,1],data_1D[:,2])\nPlots.plot!(data_1D[:,1],smoothed_data_y)","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DirectConvolution]","category":"page"},{"location":"#DirectConvolution.BoundaryExtension","page":"Home","title":"DirectConvolution.BoundaryExtension","text":"abstract type BoundaryExtension end\n\nAbstract type associated to boundary extension. \n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.ConstantBE","page":"Home","title":"DirectConvolution.ConstantBE","text":"struct ConstantBE <: BoundaryExtension end\n\nA type used to tag constant constant extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.LinearFilter","page":"Home","title":"DirectConvolution.LinearFilter","text":"abstract type LinearFilter{T<:Number} end\n\nAbstract type defining a linear filter. \n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.LinearFilter_Default","page":"Home","title":"DirectConvolution.LinearFilter_Default","text":"struct LinearFilter_Default{T<:Number,N}\n\nDefault linear filter.\n\nYou can create a filter as follows\n\njulia> linear_filter=LinearFilter([1,-2,1],1)\nFilter(r=-1:1,c=[1.0, -2.0, 1.0])\n\n\njulia> offset(linear_filter)\n1\n\n\njulia> range(linear_filter)\n-1:1\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.MirrorBE","page":"Home","title":"DirectConvolution.MirrorBE","text":"struct MirrorBE <: BoundaryExtension end\n\nA type used to tag mirror extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.PeriodicBE","page":"Home","title":"DirectConvolution.PeriodicBE","text":"struct PeriodicBE <: BoundaryExtension end\n\nA type used to tag periodic extension\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.SG_Filter","page":"Home","title":"DirectConvolution.SG_Filter","text":"function SG_Filter(T::DataType=Float64;halfWidth::Int=5,degree::Int=2)\n\nCreates a SG_Filter structure used to store Savitzky-Golay filters.\n\nfilter length is 2*halfWidth+1 \npolynomial degree is degree, which defines maxDerivativeOrder\n\nYou can apply these filters using the \n\napply_SG_filter\napply_SG_filter2D\n\nfunctions.\n\nExample:\n\njulia> sg = SG_Filter(halfWidth=5,degree=3);\n\n\njulia> maxDerivativeOrder(sg)\n3\n\njulia> length(sg)\n11\n\njulia> filter(sg,derivativeOrder=2)\nFilter(r=-5:5,c=[0.03497, 0.01399, -0.002331, -0.01399, -0.02098, -0.02331, -0.02098, -0.01399, -0.002331, 0.01399, 0.03497])\n\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.UDWT_Filter","page":"Home","title":"DirectConvolution.UDWT_Filter","text":"abstract type UDWT_Filter{T<:Number} <: UDWT_Filter_Biorthogonal{T} end\n\nA specialization of UDWT_Filter_Biorthogonal for orthogonal filters.\n\nFor orthogonal filters we have:  ϕ=tildeϕ, ψ=tildeψ\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.UDWT_Filter_Biorthogonal","page":"Home","title":"DirectConvolution.UDWT_Filter_Biorthogonal","text":"abstract type UDWT_Filter_Biorthogonal{T<:Number} end\n\nAbstract type defining the ϕ, ψ, tildeϕ and tildeψ filters associated to an undecimated biorthogonal wavelet transform\n\nSubtypes of this structure are:\n\nUDWT_Filter\n\nAssociated methods are:\n\nϕ_filter\nψ_filter\ntildeϕ_filter\ntildeψ_filter\n\n\n\n\n\n","category":"type"},{"location":"#DirectConvolution.ZeroPaddingBE","page":"Home","title":"DirectConvolution.ZeroPaddingBE","text":"struct ZeroPaddingBE <: BoundaryExtension end\n\nA type used to tag zero padding extension\n\n\n\n\n\n","category":"type"},{"location":"#Base.filter-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.filter","text":"function filter(sg::SG_Filter{T,N};derivativeOrder::Int=0)\n\nReturns the filter to be used to compute the smoothed derivatives of order derivativeOrder.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{LinearFilter}","page":"Home","title":"Base.length","text":"length(c::LinearFilter)::Int\n\nReturns filter length\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"Base.length","text":"function length(sg::SG_Filter{T,N})\n\nReturns filter length, this is an odd number.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#Base.range-Tuple{LinearFilter}","page":"Home","title":"Base.range","text":"range(c::LinearFilter)::UnitRange\n\nReturns filter range Ω\n\nFilter support of a filter α is defined by Ω = [ - offset(α), length(α) -  offset(α) - 1 ]\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.apply_SG_filter-Union{Tuple{T}, Tuple{Vector{T}, SG_Filter{T, N} where N}} where T<:AbstractFloat","page":"Home","title":"DirectConvolution.apply_SG_filter","text":"function apply_SG_filter(signal::Array{T,1},\n                         sg::SG_Filter{T};\n                         derivativeOrder::Int=0,\n                         left_BE::Type{<:BoundaryExtension}=ConstantBE,\n                         right_BE::Type{<:BoundaryExtension}=ConstantBE)\n\nApplies an 1D Savitzky-Golay and returns the smoothed signal.\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.apply_SG_filter2D-Union{Tuple{T}, Tuple{Matrix{T}, SG_Filter{T, N} where N, SG_Filter{T, N} where N}} where T<:AbstractFloat","page":"Home","title":"DirectConvolution.apply_SG_filter2D","text":"function apply_SG_filter2D(signal::Array{T,2},\n                           sg_I::SG_Filter{T},\n                           sg_J::SG_Filter{T};\n                           derivativeOrder_I::Int=0,\n                           derivativeOrder_J::Int=0,\n                           min_I_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           max_I_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           min_J_BE::Type{<:BoundaryExtension}=ConstantBE,\n                           max_J_BE::Type{<:BoundaryExtension}=ConstantBE)\n\nApplies an 2D Savitzky-Golay and returns the smoothed signal.\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.boundaryExtension","page":"Home","title":"DirectConvolution.boundaryExtension","text":"boundaryExtension(β::AbstractArray{T,1},\n                  k::Int,\n                  ::Type{BOUNDARY_EXT_TYPE})\n\nComputes extended boundary value β[k] given boundary extension type BOUNDARY_EXT_TYPE\n\nAvailable BOUNDARY_EXT_TYPE are:\n\nZeroPaddingBE: zero padding\nConstantBE: constant boundary extension padding\nPeriodicBE: periodic boundary extension padding\nMirrorBE: mirror symmetry boundary extension padding\n\nThe routine is robust in the sens that there is no restriction on k value.\n\njulia> dom = [-5:10;];\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,ZeroPaddingBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  0   0   0   0   0  0  1  2  3  0  0  0  0  0  0   0\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,ConstantBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  1   1   1   1   1  1  1  2  3  3  3  3  3  3  3   3\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,PeriodicBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  1   2   3   1   2  3  1  2  3  1  2  3  1  2  3   1\n\njulia> hcat(dom,map(x->boundaryExtension([1; 2; 3],x,MirrorBE),dom))'\n2×16 adjoint(::Matrix{Int64}) with eltype Int64:\n -5  -4  -3  -2  -1  0  1  2  3  4  5  6  7  8  9  10\n  3   2   1   2   3  2  1  2  3  2  1  2  3  2  1   2\n\n\n\n\n\n\n","category":"function"},{"location":"#DirectConvolution.directConv!-Union{Tuple{RightBE}, Tuple{LeftBE}, Tuple{T}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}, Type{LeftBE}}, Tuple{LinearFilter{T}, Int64, AbstractVector{T}, AbstractVector{T}, UnitRange{Int64}, Type{LeftBE}, Type{RightBE}}} where {T<:Number, LeftBE<:BoundaryExtension, RightBE<:BoundaryExtension}","page":"Home","title":"DirectConvolution.directConv!","text":"directConv!\n\nComputes a convolution.\n\ngammak=sumlimits_iinOmega^alphaalphaibetak+lambda i\n\nThe following example shows how to apply inplace the [0 0 1] filter on γ[5:10] \n\njulia> β=[1:15;];\n\njulia> γ=ones(Int,15);\n\njulia> α=LinearFilter([0,0,1],0);\n\njulia> directConv!(α,1,β,γ,5:10)\n\njulia> hcat([1:length(γ);],γ)\n15×2 Matrix{Int64}:\n  1   1\n  2   1\n  3   1\n  4   1\n  5   7\n  6   8\n  7   9\n  8  10\n  9  11\n 10  12\n 11   1\n 12   1\n 13   1\n 14   1\n 15   1\n\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.fcoef-Tuple{LinearFilter}","page":"Home","title":"DirectConvolution.fcoef","text":"fcoef(c::LinearFilter)\n\nReturns filter coefficients\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.maxDerivativeOrder-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"DirectConvolution.maxDerivativeOrder","text":"function maxDerivativeOrder(sg::SG_Filter{T,N})\n\nMaximum order of the smoothed derivatives we can compute using sg filters.\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.offset-Tuple{LinearFilter}","page":"Home","title":"DirectConvolution.offset","text":"offset(c::LinearFilter)::Int\n\nReturns filter offset\n\nCaveat: the first position is 0 (and not 1)\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.polynomialOrder-Union{Tuple{SG_Filter{T, N}}, Tuple{N}, Tuple{T}} where {T<:AbstractFloat, N}","page":"Home","title":"DirectConvolution.polynomialOrder","text":"function polynomialOrder(sg::SG_Filter{T,N})\n\nReturns the degree of the polynomial used to construct the Savitzky-Golay filters. This is mainly a 'convenience' function, as it is equivalent to maxDerivativeOrder\n\nSee: SG_Filter\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.scale-Tuple{Int64, UnitRange{Int64}}","page":"Home","title":"DirectConvolution.scale","text":"scale(λ::Int,Ω::UnitRange{Int})\n\nRange scaling.\n\nCaveat:\n\nWe do not use Julia * operator as it returns a step range:\n\njulia> r=6:8\n6:8\n\njulia> -2*r\n-12:-2:-16\n\nWhat we need is:\n\njulia> r=6:8\n6:8\n\njulia> scale(-2,r)\n-16:-12\n\n\n\n\n\n","category":"method"},{"location":"#DirectConvolution.ϕ_filter-Tuple{DirectConvolution.UDWT_Filter_Biorthogonal}","page":"Home","title":"DirectConvolution.ϕ_filter","text":"ϕ_filter(c::UDWT_Filter_Biorthogonal)\n\nReturns the ϕ filter\n\n\n\n\n\n","category":"method"}]
}
